const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Check for PostgreSQL DATABASE_URL
if (!process.env.DATABASE_URL) {
  console.error('ERROR: DATABASE_URL environment variable is not set.');
  console.error('Please set DATABASE_URL to a valid PostgreSQL connection string.');
  process.exit(1);
}

// Make sure the DATABASE_URL is for PostgreSQL
if (!process.env.DATABASE_URL.startsWith('postgresql://')) {
  console.error('ERROR: DATABASE_URL must be a PostgreSQL connection string.');
  console.error('Current DATABASE_URL does not start with postgresql://');
  process.exit(1);
}

console.log('Installing PostgreSQL adapter if needed...');
try {
  execSync('npm install --save @prisma/adapter-pg pg', { stdio: 'inherit' });
} catch (error) {
  console.error('Error installing PostgreSQL adapter:', error);
}

// Check if migration_lock.toml exists and modify to use PostgreSQL
console.log('Fixing migration_lock.toml to use PostgreSQL...');
const lockFilePath = path.join(__dirname, '..', 'prisma', 'migration_lock.toml');
if (fs.existsSync(lockFilePath)) {
  const content = `# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
`;
  fs.writeFileSync(lockFilePath, content);
}

// Generate Prisma client
console.log('Generating Prisma client...');
try {
  execSync('npx prisma generate', { stdio: 'inherit' });
} catch (error) {
  console.error('Error generating Prisma client:', error);
  process.exit(1);
}

// Push schema
console.log('Setting up database with prisma db push...');
try {
  console.log('Resetting database schema...');
  execSync('npx prisma db push --accept-data-loss --force-reset', { stdio: 'inherit' });
  console.log('Database schema reset and pushed successfully.');
} catch (error) {
  console.error('Error pushing schema to database:', error);
  process.exit(1);
}

// Check if tesseract-preload.ts exists at root level
const tesseractPreloadPath = path.join(__dirname, '..', 'tesseract-preload.ts');
if (!fs.existsSync(tesseractPreloadPath)) {
  console.log('Creating tesseract-preload.ts file...');
  const tesseractPreloadContent = `// Tesseract.js configuration for consistent worker setup across different environments
import { createWorker } from 'tesseract.js';

// Define Tesseract worker options with CDN paths to ensure it works in serverless environments
export const tesseractWorkerOptions = {
  workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js@5.1.1/dist/worker.min.js',
  corePath: 'https://cdn.jsdelivr.net/npm/tesseract.js-core@5.1.1/tesseract-core.wasm.js',
  langPath: 'https://tessdata.projectnaptha.com/4.0.0'
};

// Function to create a consistent Tesseract worker across different environments
export async function createTesseractWorker(options: any = {}): Promise<any> {
  const worker = await createWorker({
    ...tesseractWorkerOptions,
    logger: (m: any) => {
      if (m.status === 'recognizing text') {
        console.log(\`OCR Progress: \${Math.floor(m.progress * 100)}%\`);
      } else {
        console.log(\`OCR Status: \${m.status}\`);
      }
    },
    ...options
  });
  
  await worker.loadLanguage('eng');
  await worker.initialize('eng');
  
  return worker;
}

// Initialize Tesseract preload (if needed for specific environments)
export function initTesseractPreload() {
  console.log('Tesseract preload initialized');
  return {
    workerOptions: tesseractWorkerOptions,
    createWorker: createTesseractWorker
  };
}

export default {
  tesseractWorkerOptions,
  createTesseractWorker,
  initTesseractPreload
};`;

  fs.writeFileSync(tesseractPreloadPath, tesseractPreloadContent);
  console.log('tesseract-preload.ts created successfully.');
}

console.log('Database setup completed successfully.'); 